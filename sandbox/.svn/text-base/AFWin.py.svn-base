#! /usr/bin/env python# This program takes an mpileup input file that has been generated by the# SamTools version 0.1.12a "mpileup -gf" and processed by# SamTools version 0.1.12a bcf tools "view -cg" command.# To run the program at the command line# Type "python AFWin.py inputFile window step"# Where the inputFile is the input file name, the window is the size of# the window in terms of SNPs (not reads) and the step is the step# size of the sliding window. Eg. window of 1000 SNPs, step 100# Import the system module that is built in with Python, and the module I wroteimport sysimport AFWinMod#Name the output file, the '.csv' will make it an excel spreadsheet file, open it to write to it, and print the headings outFileName = "SNP_Frequencies.csv"outFile = open(outFileName, 'w')outFile.write(' , , , ,SNP Frequency,\nStart Scaffold, End Scaffold, Start Position, End Position,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,26, \n')# Take the input file name, window size, and step size from the command lineinputFileName = sys.argv[1]window = int(sys.argv[2])step = int(sys.argv[3])# Open the input file to read itinputFile = open(inputFileName, 'r')# Read the first two lines of the file, which are headers. Once they are read# with readline, they are out of the picture for the duration of this program.line1 = inputFile.readline()line2 = inputFile.readline()# A list/array of the allele frequency bins. Each bin represents a frequency.# The bins go from 0 to 26, because those are all possible frequencies with 8# samples that we are treating as diploid. I made a list with 27 spaces because# 0 will take up an extra spaceAFBins = [0]*27#Empty Lists: One for all the allele frequencies from every position,# one for all the scaffolds of each position, and one for the positions, and one for# the indexes of the SNPs in AFList (that is, where we find each SNP in the AFList).AFList = []scaffList = []posList = []#CI1List = []#CI2List = []SNPIndexList = []# For every line in the input file, check the criteria, get the first (lower) and second (upper)# confidence limits, the allele frequency, the scaffold, and the position. Add the allele frequency# to the list of allele frequencies, add the scaffold to the scaffold list, and add the position to the# position list. If the allele frequency is not 0 or 26, it is a SNP. We don't know if its a real SNP yet,# or a difference fixed between homeologs. If it is a SNP, real or not, add that SNP's index in# the AF list to the list of SNP indecies. To get the index in the AF list, we take the length, which# will tell us how many spaces are in the AF list, minus 1, because the 0 index takes up one space.# [For example, if the length of the AF list is 4, the index of the last AF will be 3 because the list# looks like [0,1,2,3], having four values in it.]#  for line in inputFile:        if AFWinMod.lineCriteria(line) == False:        continue    #CLimit1 = AFWinMod.getCLimit1(line)    #CLimit2 = AFWinMod.getCLimit2(line)        AF = AFWinMod.alleleFreq(line)    scaff = AFWinMod.getScaffold(line)    pos = AFWinMod.getPosition(line)        AFList.append(AF)    scaffList.append(scaff)    posList.append(pos)    #CI1List.append(CLimit1)    #CI2List.append(CLimit2)    if 0 < AF and AF <26:        SNPIndexList.append(len(AFList)-1)# This will start at 0 and go to the end of the SNP Index List. The# rage function generates a list of integers from the first argument,# up to but not including the value of the second argument. This isn't# a problem because the 0 index will push everything forward by one.#The third# argument is the step size, which is the SNP step size from the# command line. Python adds the step to each successive# integer in the result# When it gets to the very end, it will start at the beginning plus stepfor x in range (0, int(len(SNPIndexList)), step):    # Empty the allele frequency bins    AFBins = [0]*27    start = SNPIndexList[x]        if x+window >= len(SNPIndexList):        # Grab the last item in the list        end = SNPIndexList[-1]    else:        end = SNPIndexList[x+window]    # Catch everything before the first SNP    if x == 0:        start = 0    # get the scaffolds and positions of start and end    startScaff = scaffList[start]    endScaff = scaffList[end]    # If the start and end correspond to sites in    # AFList that are on different scaffolds, reduce    # end by 1 until they are on the same scaffold    while startScaff != endScaff:        end = end -1        endScaff = scaffList[end]        startPos = posList[start]    endPos = posList[end]    # If the window crosses scaffolds, skip this iteration    # This a problem because you will miss the SNPs    # between the end of the previous window and the    # start of the next, because the next one will start    # on the next scaffold.   # if startScaff != endScaff:    #    continue    # The SNPs in the window (actually, all sites in the    # window) are the AFList values from start to end.    # we use end+1 because python will take everything    # indexed up to but not including the last value    SNPsInWindow = AFList[start:end+1]    for y in SNPsInWindow:        AFWinMod.binAF(y, AFBins)    outFile.write(startScaff+','+endScaff+','+startPos+','+endPos)    a = 0    while a < len(AFBins):        outFile.write(','+str(AFBins[a]))        a += 1    outFile.write('\n')            